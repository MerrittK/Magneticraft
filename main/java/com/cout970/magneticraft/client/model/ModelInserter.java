// Date: 21/12/2014 1:16:53
// Template version 1.1
// Java generated by Techne
// Keep in mind that you still need to fill in some blanks
// - ZeuX






package com.cout970.magneticraft.client.model;

import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.entity.Entity;

public class ModelInserter extends ModelBase
{
  //fields
    ModelRenderer base;
    ModelRenderer soporte;
    ModelRenderer firstarm;
    ModelRenderer energy;
    ModelRenderer secondarm;
    ModelRenderer staticpice;
    ModelRenderer hook1;
    ModelRenderer hook2;
  
  public ModelInserter()
  {
    textureWidth = 64;
    textureHeight = 32;
    
      base = new ModelRenderer(this, 0, 0);
      base.addBox(-8F, 7F, -8F, 16, 1, 16);
      base.setRotationPoint(0F, 16F, 0F);
      base.setTextureSize(64, 32);
      base.mirror = true;
      setRotation(base, 0F, 0F, 0F);
      soporte = new ModelRenderer(this, 0, 17);
      soporte.addBox(-4F, 4F, -4F, 8, 3, 8);
      soporte.setRotationPoint(0F, 16F, 0F);
      soporte.setTextureSize(64, 32);
      soporte.mirror = true;
      setRotation(soporte, 0F, 0F, 0F);
      firstarm = new ModelRenderer(this, 32, 17);
      firstarm.addBox(-1F, -10F, -1F, 2, 10, 2);
      firstarm.setRotationPoint(0F, 20F, 0F);
      firstarm.setTextureSize(64, 32);
      firstarm.mirror = true;
      setRotation(firstarm, 0F, 0F, 0F);
      energy = new ModelRenderer(this, 40, 17);
      energy.addBox(7F, 5F, -2F, 1, 2, 4);
      energy.setRotationPoint(0F, 16F, 0F);
      energy.setTextureSize(64, 32);
      energy.mirror = true;
      setRotation(energy, 0F, 0F, 0F);
      secondarm = new ModelRenderer(this, 52, 17);
      secondarm.addBox(-1F, -10F, -1F, 2, 10, 2);
      secondarm.setRotationPoint(0F, 10F, 0F);
      secondarm.setTextureSize(64, 32);
      secondarm.mirror = true;
      setRotation(secondarm, 0F, 0F, 0F);
      staticpice = new ModelRenderer(this, 40, 23);
      staticpice.addBox(-1F, 0F, -2F, 2, 1, 4);
      staticpice.setRotationPoint(0F, 0F, 0F);
      staticpice.setTextureSize(64, 32);
      staticpice.mirror = true;
      setRotation(staticpice, 0F, 0F, 0F);
      hook1 = new ModelRenderer(this, 0, 28);
      hook1.addBox(-1F, -3F, 2F, 2, 3, 1);
      hook1.setRotationPoint(0F, 0F, 0F);
      hook1.setTextureSize(64, 32);
      hook1.mirror = true;
      setRotation(hook1, 0F, 0F, 0F);
      hook2 = new ModelRenderer(this, 6, 28);
      hook2.addBox(-1F, -3F, -3F, 2, 3, 1);
      hook2.setRotationPoint(0F, 0F, 0F);
      hook2.setTextureSize(64, 32);
      hook2.mirror = true;
      setRotation(hook2, 0F, 0F, 0F);
  }
  
  public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
  {
    super.render(entity, f, f1, f2, f3, f4, f5);
    setRotationAngles(f, f1, f2, f3, f4, f5, entity);
    base.render(f5);
    soporte.render(f5);
    firstarm.render(f5);
    energy.render(f5);
    secondarm.render(f5);
    staticpice.render(f5);
    hook1.render(f5);
    hook2.render(f5);
  }
  
  private void setRotation(ModelRenderer model, float x, float y, float z)
  {
    model.rotateAngleX = x;
    model.rotateAngleY = y;
    model.rotateAngleZ = z;
  }

  public void renderStatic(float f5) {
	  base.render(f5);
	  soporte.render(f5);
//	  energy.render(f5);
  }

  public void renderDynamic(float f5,float a1, float a2,float ap){
	  float rad1 = (float) Math.toRadians(a1);
	  float rad2 = (float) Math.toRadians(a2);
	  float rad3 = ap*0.000625f;
	  
	  firstarm.rotateAngleX = rad1;
	  
	  secondarm.offsetZ = (float) -Math.sin(rad1)*0.625f;
	  secondarm.offsetY = (float) -Math.cos(rad1)*0.625f+0.625f;
	  secondarm.rotateAngleX = rad2;
	  
	  staticpice.offsetZ = (float) -Math.sin(rad1)*0.625f - (float) Math.sin(rad2)*0.625f;
	  staticpice.offsetY = (float) -Math.cos(rad1)*0.625f - (float) Math.cos(rad2)*0.625f + 1.25f;
	  staticpice.rotateAngleX = rad2;
	  
	  hook1.offsetZ = (float) (-Math.sin(rad1)*0.625f - Math.sin(rad2)*0.625f - rad3*Math.cos(rad2));
	  hook1.offsetY = (float) (-Math.cos(rad1)*0.625f - Math.cos(rad2)*0.625f + rad3*Math.sin(rad2) + 1.25f);
	 
	  hook2.offsetZ = (float) (-Math.sin(rad1)*0.625f - Math.sin(rad2)*0.625f + rad3*Math.cos(rad2));
	  hook2.offsetY = (float) (-Math.cos(rad1)*0.625f - Math.cos(rad2)*0.625f - rad3*Math.sin(rad2) + 1.25f);
	  
	  hook1.rotateAngleX = rad2;
	  hook2.rotateAngleX = rad2;
	  
	  firstarm.render(f5);
	  secondarm.render(f5);
	  staticpice.render(f5);
	  hook1.render(f5);
	  hook2.render(f5);
  }
}
