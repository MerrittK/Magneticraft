package com.cout970.magneticraft.tileentity;

import net.minecraft.tileentity.TileEntity;
import net.minecraft.world.World;
import akka.event.Logging.Debug;

import com.cout970.magneticraft.api.electricity.CompoundElectricCables;
import com.cout970.magneticraft.api.electricity.ConnectionClass;
import com.cout970.magneticraft.api.electricity.ElectricConductor;
import com.cout970.magneticraft.api.electricity.ElectricConstants;
import com.cout970.magneticraft.api.electricity.IElectricConductor;
import com.cout970.magneticraft.api.electricity.IEnergyInterface;
import com.cout970.magneticraft.api.electricity.IndexedConnection;
import com.cout970.magneticraft.api.util.MgDirection;
import com.cout970.magneticraft.api.util.MgUtils;
import com.cout970.magneticraft.api.util.VecInt;
import com.cout970.magneticraft.api.util.VecIntUtil;
import com.cout970.magneticraft.util.Log;
import com.cout970.magneticraft.util.tile.TileConductorLow;

public class TileDiode extends TileConductorLow{

	@Override
	public IElectricConductor initConductor() {
		return new ElectricConductor(this, 5){
			
			@Override
			public void recache(){
				if(!connected){
					connected = true;
					con.clear();
					int sides = 0;
					for(VecInt f : getValidConnections()){
						TileEntity target = MgUtils.getTileEntity(tile, f);
						CompoundElectricCables c = MgUtils.getElectricCond(target, f.getOpposite(), getTier());
						IEnergyInterface inter = MgUtils.getInterface(target, f.getOpposite(), getTier());
						if(c != null){
							for(IElectricConductor e : c.list()){
								if(e == this)continue;
								if(this.isAbleToConnect(e, f) && e.isAbleToConnect(this, f.getOpposite())){
									con.add(new IndexedConnection(this, f,e,sides));
									sides++;
								}
							}
						}
						if(inter != null && inter.canConnect(f)){
							con.add(new IndexedConnection(this, f, inter,sides));
							sides++;
						}
					}
					if(currents == null){
						currents = new double[sides];
					}else{
						if(currents.length != sides){
							double[] temp = new double[sides];
							for(int i=0;i< Math.min(sides, currents.length);i++){
								temp[i] = currents[i];
							}
							currents = temp;
						}
					}
					Log.debug(con.size());
				}
			}
			
			@Override
			public void iterate() {
				TileEntity tile = getParent();
				World w = tile.getWorldObj();
				if(w.isRemote)return;
				tile.markDirty();
				this.getVoltage();

				for(IndexedConnection f : con){
					IElectricConductor cond = f.cond;
					IEnergyInterface c = f.inter;
					if(cond != null && cond.canFlowPower(f)){
						//the resistance of the connection
						double resistence = (this.getResistance() + cond.getResistance());
						//the voltage differennce
						double deltaV = this.V - cond.getVoltage();
						//sanity check for infinite current
						if(Double.isNaN(currents[f.index]))currents[f.index] = 0;
						//the extra current from the last tick
						double current = currents[f.index];
						// (V - I*R) I*R is the voltage difference that this conductor should have using the ohm's law, and V the real one
						//vDiff is the voltage difference bvetween the current voltager difference and the proper voltage difference using the ohm's law
						double vDiff = (deltaV - current * resistence);
						//make sure the vDiff is not in the incorrect direction when the resistance is too big
						vDiff = Math.min(vDiff, Math.abs(deltaV));
						vDiff = Math.max(vDiff, -Math.abs(deltaV));
						// add to the next tick current an extra to get the proper voltage difference on the two conductors
						currents[f.index] += (vDiff * getIndScale())/getVoltageMultiplier();	
						// to the extra current add the current generated by the voltage difference
						current += (deltaV * getCondParallel())/(getVoltageMultiplier());
						//moves the charge
						if(getDirection().toVecInt().equals(f.vecDir)){
							if(deltaV > 0.5){
								this.applyCurrent(-current);
								cond.applyCurrent(current);
							}
						}else{
							this.applyCurrent(-current);
							cond.applyCurrent(current);
						}
					}
					if(c != null){
						if(V > ElectricConstants.ENERGY_INTERFACE_LEVEL && c.canAcceptEnergy(f)){
							double watt = Math.min(c.getMaxFlow(), (V-ElectricConstants.ENERGY_INTERFACE_LEVEL)*ElectricConstants.CONVERSION_SPEED);
							if(watt > 0)
							drainPower(c.applyEnergy(watt));
						}
					}
				}
			}
			
			@Override
			public VecInt[] getValidConnections() {
				return new VecInt[]{getDirection().toVecInt(), getDirection().opposite().toVecInt()};
			}
			
			@Override
			public boolean canFlowPower(IndexedConnection con) {
				return con.source.getClass().isAssignableFrom(getClass());
			}
			
			@Override
			public ConnectionClass getConnectionClass(VecInt v) {
				return ConnectionClass.CABLE_LOW;
			}
		};
	}

	@Override
	public CompoundElectricCables getConds(VecInt dir, int tier) {
		if(tier != 0 && tier !=-1)return null;
		if(dir == VecInt.NULL_VECTOR || getDirection().toVecInt().equals(dir) || getDirection().opposite().toVecInt().equals(dir))
		return new CompoundElectricCables(cond);
		return null;
	}
	
	public MgDirection getDirection() {
		return MgDirection.getDirection(getBlockMetadata());
	}
}
